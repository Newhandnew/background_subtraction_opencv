#include <iostream>
#include "opencv2/opencv.hpp"
#include "opencv2/core/utility.hpp"
  
using namespace cv;  
using namespace std;  

static const char* keys =
{ 
    "{@video_name  | | video name            }"
};
  
int main(int argc, char** argv)  
{  
	CommandLineParser parser( argc, argv, keys );
  	String video_name = parser.get<String>( 0 );
    if (video_name.empty())
	{
		cout << "video_name is empty" << endl;
		return -1;
	}

	VideoCapture cap;  
    cap.open(video_name);  
    //cap.open("test_02.wmv"); 
  
    if( !cap.isOpened() )
    {
        cout << "video didn't open!" << endl;
        return -1;  
    }
  
    Mat frame;  
    Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
    Mat fgMaskKNN;
    Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
    Ptr<BackgroundSubtractor> pKNN;
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
    pKNN = createBackgroundSubtractorKNN();

    RNG rng(12345);
    int minBoundingArea = 400;
    int dilationIteration = 3;
    int numLimitBounding = 200;

    for(;;)  
    {  
        double t = (double)cvGetTickCount();  
  
        cap >> frame;  
        if(frame.empty())
        {
            cout << "end of video" << endl;
            break;
        }
        //update the background model
        pMOG2->apply(frame, fgMaskMOG2, 0.1);
        pKNN->apply(frame, fgMaskKNN, 0.1);
        //get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        ss << cap.get(CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

        //resize
        resize(frame, frame, Size(frame.cols / 2, frame.rows / 2));
        resize(fgMaskMOG2, fgMaskMOG2, Size(fgMaskMOG2.cols / 2, fgMaskMOG2.rows / 2));
        resize(fgMaskKNN, fgMaskKNN, Size(fgMaskKNN.cols / 2, fgMaskKNN.rows / 2));
        //show the current frame and the fg masks
        imshow("Frame", frame);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        imshow("FG Mask KNN", fgMaskKNN);

        // Mat imgErosion, imgDilation;
        // erode(fgMaskKNN, imgErosion, Mat());
        // imshow("erosion", imgErosion);
        // dilate(imgErosion, imgDilation, Mat(), Point(-1,-1), dilationIteration);
        // imshow("dilation", imgDilation);

        // // show contour rectangles
        // vector<vector<Point> > contours;
        // vector<Vec4i> hierarchy;
        // findContours( imgDilation, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );
        // int numContours = contours.size();
        // cout << "bounding box number: " << numContours << endl;
        // if (numContours < numLimitBounding)
        // {
        //     for( int i = 0; i < numContours; i++ )
        //     {
        //         if (contourArea(contours[i]) > minBoundingArea)
        //         {
        //             Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
        //             Rect boundRect = boundingRect(contours[i]);
        //             rectangle( frame, Point(boundRect.x, boundRect.y), Point(boundRect.x + boundRect.width, boundRect.y + boundRect.height), color, 2, 8, 0 );
        //         }
        //     }
        // }

        // imshow( "Contours", frame );

        //get the input from the keyboard
        char keyboard = waitKey( 10 );
  
        
        if(keyboard == 27)
        {
            cout <<"exit" << endl;
            break;
        }

  
        t = (double)cvGetTickCount() - t;  
        cout << "cost time: " << t / ((double)cvGetTickFrequency()*1000.) << endl;  
    }  
    return 0;  
}  
