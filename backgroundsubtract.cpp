#include <iostream>
#include "opencv2/opencv.hpp"
#include "opencv2/core/utility.hpp"
  
using namespace cv;  
using namespace std;  

static const char* keys =
{ 
    "{@video_name  | | video name            }"
};
  
int main(int argc, char** argv)  
{  
	CommandLineParser parser( argc, argv, keys );
  	String video_name = parser.get<String>( 0 );
    if (video_name.empty())
	{
		cout << "video_name is empty" << endl;
		return -1;
	}

	VideoCapture cap;  
    cap.open(video_name);  
    //cap.open("test_02.wmv"); 
  
    if( !cap.isOpened() )
    {
        cout << "video didn't open!" << endl;
        return -1;  
    }
  
    Mat frame;  
    Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
    Mat fgMaskKNN;
    Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
    Ptr<BackgroundSubtractor> pKNN;
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
    pKNN = createBackgroundSubtractorKNN();

    double costTime;
    int perFrameTime = 30;
    char keyboard;

    RNG rng(12345);
    int minBoundingArea = 300;
    int dilationIteration = 3;
    int numLimitBounding = 100;

    Mat imgBoundingBox;

    for(;;)  
    {  
        double t = (double)getTickCount();  
  
        cap >> frame;  
        if(frame.empty())
        {
            cout << "end of video" << endl;
            break;
        }
        //update the background model
        // pMOG2->apply(frame, fgMaskMOG2, 0.1);
        pKNN->apply(frame, fgMaskKNN, 0.02);
        //get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        ss << cap.get(CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
        //show the current frame and the fg masks
        // imshow("Frame", frame);
        // imshow("FG Mask MOG 2", fgMaskMOG2);
        imshow("FG Mask KNN", fgMaskKNN);

        Mat imgErosion, imgDilation;
        erode(fgMaskKNN, imgErosion, Mat());
        imshow("erosion", imgErosion);
        dilate(imgErosion, imgDilation, Mat(), Point(-1,-1), dilationIteration);
        imshow("dilation", imgDilation);
        cout << imgDilation.type() << endl;

        Mat imgProposed;
        Mat imgRed(frame.size(), frame.type(), Scalar(0, 0, 255));
        imgRed.copyTo(imgProposed, imgDilation);
        addWeighted(frame , 0.8, imgProposed, 0.3, 0, imgProposed, 0);
        imshow("Proposed", imgProposed);

        // show contour rectangles
        vector<vector<Point> > contours;
        vector<Vec4i> hierarchy;
        findContours( imgDilation, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );
        int numContours = contours.size();
        cout << "bounding box number: " << numContours << endl;
        frame.copyTo(imgBoundingBox);
        if (numContours < numLimitBounding)
        {
            for( int i = 0; i < numContours; i++ )
            {
                if (contourArea(contours[i]) > minBoundingArea)
                {
                    Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
                    Rect boundRect = boundingRect(contours[i]);
                    rectangle( imgBoundingBox, Point(boundRect.x, boundRect.y), Point(boundRect.x + boundRect.width, boundRect.y + boundRect.height), Scalar(255,0,0), 2, 8, 0 );
                }
            }
        }

        imshow("Bounding Box", imgBoundingBox );

        t = (double)getTickCount() - t;
        costTime = t / (double)getTickFrequency() * 1000;
        cout << "cost time: " << costTime << endl;
        if (costTime < perFrameTime)
        {
            keyboard = waitKey(1 + perFrameTime - costTime);
        }
        else
        {
            keyboard = waitKey(1);
            cout << "in > 30" << endl;
        }
        if(keyboard == 27)
        {
            cout <<"exit" << endl;
            break;
        }
    }  
    return 0;  
}  
